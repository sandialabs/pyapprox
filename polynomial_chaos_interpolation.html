

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Polynomial Chaos Regression &mdash; PyApprox 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"V": ["{\\boldsymbol{#1}}", 1], "mean": ["{\\mathbb{E}\\left[#1\\right]}", 1], "var": ["{\\mathbb{V}\\left[#1\\right]}", 1], "argmin": "{\\mathrm{argmin}}", "rv": "z", "reals": "\\mathbb{R}", "pdf": "\\rho", "rvdom": "\\Gamma", "coloneqq": "\\colon=", "norm": ["\\lVert #1 \\rVert", 1], "argmax": ["\\operatorname{argmax}"]}}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Adaptive Leja Sequences" href="adaptive_leja_sequences.html" />
    <link rel="prev" title="Compute isotropic sparse grid quadrature rule" href="isotropic_sparse_grid_quadrature_example.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> PyApprox
          

          
            
            <img src="_static/pyapprox-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="parameter_sweeps.html">Parameter Sweeps</a></li>
<li class="toctree-l2"><a class="reference internal" href="tensor_product_lagrange_interpolation.html">Tensor product Lagrange interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="isotropic_sparse_grid_quadrature_example.html">Compute isotropic sparse grid quadrature rule</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Polynomial Chaos Regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="adaptive_leja_sequences.html">Adaptive Leja Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="cantilever_beam.html">Cantilever Beam</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyApprox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="examples.html">Examples</a> &raquo;</li>
        
      <li>Polynomial Chaos Regression</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/polynomial_chaos_interpolation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="polynomial-chaos-regression">
<span id="id1"></span><h1>Polynomial Chaos Regression<a class="headerlink" href="#polynomial-chaos-regression" title="Permalink to this headline">¶</a></h1>
<p>This tutorial discusses how to construct a polynomial chaos expansion of a function with uncertain parameters using least squares regression.</p>
<p>Lets first import the necessary modules and set the random seed to ensure the exact plots of this tutorial are reproducbile,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyapprox.variables</span> <span class="kn">import</span> <span class="n">IndependentMultivariateRandomVariable</span>
<span class="kn">from</span> <span class="nn">pyapprox.variable_transformations</span> <span class="kn">import</span> \
<span class="n">AffineRandomVariableTransformation</span>
<span class="kn">from</span> <span class="nn">pyapprox.multivariate_polynomials</span> <span class="kn">import</span> <span class="n">PolynomialChaosExpansion</span><span class="p">,</span>\
<span class="n">define_poly_options_from_variable_transformation</span>
<span class="kn">from</span> <span class="nn">pyapprox.probability_measure_sampling</span> <span class="kn">import</span> \
<span class="n">generate_independent_random_samples</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">beta</span>
<span class="kn">from</span> <span class="nn">pyapprox.indexing</span> <span class="kn">import</span> <span class="n">compute_hyperbolic_indices</span><span class="p">,</span> <span class="n">tensor_product_indices</span>
<span class="kn">from</span> <span class="nn">pyapprox.models.genz</span> <span class="kn">import</span> <span class="n">GenzFunction</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pyapprox.univariate_quadrature</span> <span class="kn">import</span> <span class="n">gauss_jacobi_pts_wts_1D</span><span class="p">,</span> \
<span class="n">clenshaw_curtis_in_polynomial_order</span>
<span class="kn">from</span> <span class="nn">pyapprox.utilities</span> <span class="kn">import</span> <span class="n">get_tensor_product_quadrature_rule</span>
<span class="kn">from</span> <span class="nn">pyapprox.polynomial_sampling</span> <span class="kn">import</span> <span class="n">christoffel_weights</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-1.py">Source code</a>)</p>
<p>Our goal is to demonstrate how to use a polynomial chaos expansion (PCE) to approximate a function <span class="math notranslate nohighlight">\(f(z): \reals^d \rightarrow \reals\)</span> parameterized by the random variables <span class="math notranslate nohighlight">\(z=(z_1,\ldots,z_d)\)</span>. with the joint probability density function <span class="math notranslate nohighlight">\(\pdf(\V{\rv})\)</span>. In the following we will use a function commonly used in the literature, the oscillatory Genz function. This function is well suited for testing as the number of variables and the non-linearity can be adjusted.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">univariate_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniform</span><span class="p">(),</span><span class="n">beta</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">variable</span> <span class="o">=</span> <span class="n">IndependentMultivariateRandomVariable</span><span class="p">(</span><span class="n">univariate_variables</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">variable</span><span class="o">.</span><span class="n">num_vars</span><span class="p">())</span>
<span class="n">c</span><span class="o">*=</span><span class="mi">4</span><span class="o">/</span><span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">GenzFunction</span><span class="p">(</span> <span class="s2">&quot;oscillatory&quot;</span><span class="p">,</span><span class="n">variable</span><span class="o">.</span><span class="n">num_vars</span><span class="p">(),</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">w</span> <span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-2.py">Source code</a>)</p>
<p>PCE represent the model output <span class="math notranslate nohighlight">\(f(\V{\rv})\)</span> as an expansion in orthonormal polynomials,</p>
<div class="math notranslate nohighlight" id="equation-eq-pce-integer-index">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-pce-integer-index" title="Permalink to this equation">¶</a></span>\[f(\V{\rv})\approx p(\V{\rv})=\sum_{n=1}^\infty \alpha_n\phi_n(\V{\rv}),\]</div>
<p>Here <span class="math notranslate nohighlight">\(\alpha_n\)</span> are the PCE coefficients that must be computed, and the basis functions <span class="math notranslate nohighlight">\(\phi_n\)</span> are polynomial basis functions that are pairwise orthonormal under an inner product weighted by the probability density of <span class="math notranslate nohighlight">\(\V{\rv}\)</span>. Above we assume that <span class="math notranslate nohighlight">\(f\)</span> is scalar-valued, but the procedures we describe carry over to vector- or function-valued outputs.
In this tutorial the components of <span class="math notranslate nohighlight">\(\V{\rv}\)</span> are independent and so we can generate the multivariate polynomials <span class="math notranslate nohighlight">\(\phi_n\)</span> from univariate orthogonal polynomials, but such a construction can also be accomplished when <span class="math notranslate nohighlight">\(\V{\rv}\)</span> has dependent components. This will be demonstrated in another tutorial.</p>
<p>Polynomial chaos expansions are most easily constructed when the components of <span class="math notranslate nohighlight">\(\rv\)</span> are independent.  Under the assumption of independence, we have</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
\rvdom &amp;= \times_{i=1}^d \rvdom_i, &amp; \rvdom_i &amp;\subseteq \reals, &amp; \pdf(\V{\rv}) &amp;= \prod_{i=1}^d \pdf_i(\rv_i),
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(\pdf_i\)</span> are the marginal densities of the variables <span class="math notranslate nohighlight">\(\V{\rv}_i\)</span>, which completely characterizes the distribution of <span class="math notranslate nohighlight">\(\rv\)</span>. This allows us to express the basis functions <span class="math notranslate nohighlight">\(\phi\)</span> as tensor products of univariate orthonormal polynomials. That is</p>
<div class="math notranslate nohighlight">
\[\phi_\lambda(\V{\rv})=\prod_{i=1}^d \phi^i_{\lambda_i}(\rv_i),\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda=(\lambda_1\ldots,\lambda_d)\in\mathbb{N}_0^d\)</span> is a multi-index, and the univariate basis functions <span class="math notranslate nohighlight">\(\phi^i_j\)</span> are defined uniquely (up to a sign) for each <span class="math notranslate nohighlight">\(i = 1, \ldots, d\)</span>, as</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
\int_{\rvdom_i} \phi^i_{j}(z_i) \phi^i_{k}(z_i) \pdf_i(z_i) \;dz_i &amp;= \delta_{j,k}, &amp; j, k &amp;\geq 0, &amp; \deg \phi^i_j &amp;= j.
\end{align*}\]</div>
<p>With this notation, the degree of the multivariate polynomial <span class="math notranslate nohighlight">\(\phi_\lambda\)</span> is <span class="math notranslate nohighlight">\(|\lambda| \colon= \sum_{j=1}^d \lambda_j\)</span>.</p>
<p>The following code initializes a PCE with univariate polynomials orthonormal to the random variables.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">var_trans</span> <span class="o">=</span> <span class="n">AffineRandomVariableTransformation</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
<span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialChaosExpansion</span><span class="p">()</span>
<span class="n">poly_opts</span> <span class="o">=</span> <span class="n">define_poly_options_from_variable_transformation</span><span class="p">(</span><span class="n">var_trans</span><span class="p">)</span>
<span class="n">poly</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">poly_opts</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-3.py">Source code</a>)</p>
<p>In practice the PCE  must be truncated to some finite number of terms, say <span class="math notranslate nohighlight">\(N\)</span>, defined by a multi-index set <span class="math notranslate nohighlight">\(\Lambda \subset \mathbb{N}_0^d\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-pce-multi-index">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-pce-multi-index" title="Permalink to this equation">¶</a></span>\[\begin{align*}
\label{eq:pce-multi-index}
f(\V{\rv}) &amp;\approx f_N(\V{\rv}) = \sum_{\lambda\in\Lambda}\alpha_{\lambda}\phi_{\lambda}(\V{\rv}), &amp; |\Lambda| &amp;= N.
\end{align*}\]</div>
<p>Frequently the PCE is truncated to retain only the multivariate polynomials whose associated multi-indices have norm at most <span class="math notranslate nohighlight">\(p\)</span>, i.e.,</p>
<div class="math notranslate nohighlight">
\[\label{eq:hyperbolic-index-set}
\begin{align*}
\Lambda &amp;= \Lambda^d_{p,q} = \{\lambda \mid \norm{\lambda}{q} \le p\}., &amp; \left\| \lambda \right\|_q &amp;\coloneqq \left(\sum_{i=1}^d \lambda^q_i\right)^{1/q}.
\end{align*}\]</div>
<p>Taking <span class="math notranslate nohighlight">\(q=1\)</span> results in a total-degree space having dimension <span class="math notranslate nohighlight">\(\text{card}\; \Lambda^d_{p,1} \equiv N = { d+p \choose d }\)</span>. The choice of <span class="math notranslate nohighlight">\(\Lambda\)</span> identifies a subspace in which <span class="math notranslate nohighlight">\(f_N\)</span> has membership:</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
\pi_\Lambda &amp;\coloneqq \mathrm{span} \left\{ \phi_\lambda \;\; \big| \;\; \lambda \in \Lambda \right\}, &amp; f_N &amp;\in \pi_\Lambda.
\end{align*}\]</div>
<p>Under an appropriate ordering of multi-indices, the expression <a class="reference internal" href="#equation-eq-pce-integer-index">(1)</a> , and the expression <a class="reference internal" href="#equation-eq-pce-multi-index">(2)</a> truncated to the first <span class="math notranslate nohighlight">\(N\)</span> terms, are identical. Defining <span class="math notranslate nohighlight">\([N]:=\{1,\ldots,N\}\)</span>, for <span class="math notranslate nohighlight">\(N\in\mathbb{N}\)</span>, we will in the following frequently make use of a linear ordering of the PCE basis, <span class="math notranslate nohighlight">\(\phi_k\)</span> for <span class="math notranslate nohighlight">\(k \in [N]\)</span> from <a class="reference internal" href="#equation-eq-pce-integer-index">(1)</a>, instead of the multi-index ordering of the PCE basis <span class="math notranslate nohighlight">\(\phi_{\lambda}\)</span> for <span class="math notranslate nohighlight">\(\lambda \in \Lambda\)</span> from <a class="reference internal" href="#equation-eq-pce-multi-index">(2)</a>.  Therefore,</p>
<div class="math notranslate nohighlight">
\[\sum_{\lambda \in \Lambda} \alpha_\lambda \phi_\lambda(\V{\rv}) = \sum_{n=1}^N \alpha_n \phi_n(\V{\rv}).\]</div>
<p>Any bijective map between <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\([N]\)</span> will serve to define this linear ordering, and the particular choice of this map is not relevant in our discussion.</p>
<p>To set the PCE truncation to a third degree total-degree index set use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">degree</span><span class="o">=</span><span class="mi">3</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">compute_hyperbolic_indices</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">num_vars</span><span class="p">(),</span><span class="n">degree</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">poly</span><span class="o">.</span><span class="n">set_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-4.py">Source code</a>)</p>
<p>Now we have defined the PCE, we are now must compute its coefficients. Pyapprox supports a number of methods to compute the polynomial coefficients. Here we will use interpolation. Specifically we evaluate the function at a set of samples <span class="math notranslate nohighlight">\(\mathcal{Z}=[\V{\rv}^{(1)},\ldots,\V{\rv}^{(M)}]\)</span> to obtain a set of function values <span class="math notranslate nohighlight">\(\V{f}=[\V{f}^{(1)},\ldots,\V{f}^{(M)}]^T\)</span>. The function may be vectored valued and thus each <span class="math notranslate nohighlight">\(\V{f}^{(i)}\in\mathbb{R}^Q\)</span> is a vector and <span class="math notranslate nohighlight">\(\V{F}\in\mathbb{R}^{M\times Q}\)</span> is a matrix</p>
<p>In the following we will generate training samples by randomly drawing samples from the tensor-product Chebyshev measure.</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
v(\V{\rv})=\prod_{i=1}^d v(\rv_i) &amp; &amp; v(\rv_i)=\frac{1}{\pi\sqrt{1-\rv_i^2}}
\end{align*}\]</div>
<p>Sampling from this measure is asymptorically optimal (as degree increases) for any bounded random variable <a class="reference internal" href="#njz2017" id="id2"><span>[NJZ2017]</span></a>. The following code samples from the Chebyshev measure and evaluates the model at these samples.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ntrain_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
<span class="n">train_samples</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,(</span><span class="n">poly</span><span class="o">.</span><span class="n">num_vars</span><span class="p">(),</span><span class="n">ntrain_samples</span><span class="p">)))</span>
<span class="n">train_samples</span> <span class="o">=</span> <span class="n">var_trans</span><span class="o">.</span><span class="n">map_from_canonical_space</span><span class="p">(</span><span class="n">train_samples</span><span class="p">)</span>
<span class="n">train_values</span>  <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">train_samples</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-5.py">Source code</a>)</p>
<p>Here we have used the variable transformation to map the samples from
<span class="math notranslate nohighlight">\([-1,1]^d\rightarrow[0,1]^d\)</span>. More details on how to use variable transformations will be covered
in another tutorial.</p>
<p>The function values we generated can now be used to approximate the polynomial coefficients by solving the least squares system</p>
<div class="math notranslate nohighlight">
\[\V{\Phi} \V{\alpha}=\V{F}\]</div>
<p>where entries of the basis matrix <span class="math notranslate nohighlight">\(\V{\Phi}\in\mathbb{R}^{M\times N}\)</span> are given by <span class="math notranslate nohighlight">\(\Phi_{ij}=\phi_j(\V{\rv}^{(i)})\)</span>. Solving this system will be ill conditioned so we must precondition the system using an appropriate preconditioner. The optimal preconditioner when sampling from the Chebyshev measure is a diagonal matrix <span class="math notranslate nohighlight">\(\V{w}\)</span> with entries</p>
<div class="math notranslate nohighlight">
\[W_{ii}=\left(\sum_{n=1}^N \phi_n^2(\V{\rv}^{(i)})\right)^{-\frac{1}{2}}\]</div>
<p>We will use numpy’s in built least squares function to solve the preconditioned system of equations</p>
<div class="math notranslate nohighlight">
\[\V{W}\V{\Phi} \V{\alpha}=\V{W}\V{F}\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">basis_matrix</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">basis_matrix</span><span class="p">(</span><span class="n">train_samples</span><span class="p">)</span>
<span class="n">precond_weights</span> <span class="o">=</span> <span class="n">christoffel_weights</span><span class="p">(</span><span class="n">basis_matrix</span><span class="p">)</span>
<span class="n">precond_basis_matrix</span> <span class="o">=</span> <span class="n">precond_weights</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">basis_matrix</span>
<span class="n">precond_train_values</span> <span class="o">=</span> <span class="n">precond_weights</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">train_values</span>
<span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">precond_basis_matrix</span><span class="p">,</span><span class="n">precond_train_values</span><span class="p">,</span><span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">poly</span><span class="o">.</span><span class="n">set_coefficients</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-6.py">Source code</a>)</p>
<p>Now lets plot the Genz function and the error in the PCE approximation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">num_pts_1d</span> <span class="o">=</span> <span class="mi">30</span>
<span class="kn">from</span> <span class="nn">pyapprox.configure_plots</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyapprox.visualization</span> <span class="kn">import</span> <span class="n">plot_surface</span><span class="p">,</span> <span class="n">get_meshgrid_function_data</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">get_meshgrid_function_data</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">plot_limits</span><span class="p">,</span> <span class="n">num_pts_1d</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>

<span class="n">ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">poly</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">get_meshgrid_function_data</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">plot_limits</span><span class="p">,</span> <span class="n">num_pts_1d</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">Z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="mi">2</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">train_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">train_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span>
<span class="c1">#offset*np.ones(train_samples.shape[1]),&#39;o&#39;,zorder=100,color=&#39;b&#39;)</span>
<span class="n">error</span><span class="p">(</span><span class="n">train_samples</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href=".//polynomial_chaos_interpolation-7.py">Source code</a>, <a class="reference external" href=".//polynomial_chaos_interpolation-7.png">png</a>, <a class="reference external" href=".//polynomial_chaos_interpolation-7.hires.png">hires.png</a>, <a class="reference external" href=".//polynomial_chaos_interpolation-7.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="_images/polynomial_chaos_interpolation-7.png" src="_images/polynomial_chaos_interpolation-7.png" />
</div>
<p>As you can see the error in the interpolant is small near the training points and larger further away from those points.</p>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p>In this tutorial we sampled from the Chebyshev measure and applied a preconditioner (known as the Christoffel function) to generate a well-conditioned linear system. Other strategies exists for generating well conditioned systems. We will cover other choices and provide more information on the preconditioning techinque used here in another tutorial. However we want to emphasize that random sampling from the probability measure does not produce a well-conditioned system and should be avoided.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="citation">
<dt class="label" id="njz2017"><span class="brackets"><a class="fn-backref" href="#id2">NJZ2017</a></span></dt>
<dd><p><a class="reference external" href="https://doi.org/10.1090/mcom/3192">Narayan A., Jakeman J., Zhou T. A christoffel function weighted least squares algorithm for collocation approximations Math. Comp., 86 (306) (2017), pp. 1913-1947</a></p>
</dd>
<dt class="label" id="jnz2017"><span class="brackets">JNZ2017</span></dt>
<dd><p><a class="reference external" href="https://epubs.siam.org/doi/10.1137/16M1063885">Jakeman J.D., Narayan A., Zhou T. A generalized sampling and preconditioning scheme for sparse approximation of polynomial chaos expansions. SIAM J. Sci. Comput., 39 (3) (2017), pp. A1114-A1144.</a></p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="adaptive_leja_sequences.html" class="btn btn-neutral float-right" title="Adaptive Leja Sequences" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="isotropic_sparse_grid_quadrature_example.html" class="btn btn-neutral float-left" title="Compute isotropic sparse grid quadrature rule" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>